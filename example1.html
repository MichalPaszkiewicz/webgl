<html>
	<head>
		<title>Example 1</title>
		<script src="standard.js"></script>
	</head>
	<body>
		<canvas id="canvas" style="border: none;" width="500" height="500"></canvas>
			<script id="shader-fs" type="x-shader/x-fragment">
				void main(void) {
					gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
				}
			</script>
			<script id="shader-vs" type="x-shader/x-vertex">
				attribute vec3 aVertexPosition;
				uniform mat4 uMVMatrix;
				uniform mat4 uPMatrix;
				void main(void) {
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				}
			</script>
			<script>
				function start() {
					var canvas = document.getElementById("canvas");
				
					gl = initWebGL(canvas);      // Initialize the GL context
				  
					// Only continue if WebGL is available and working
					  
					if (gl) {
						gl.clearColor(0.0, 0.0, 0.0, 1.0);                      // Set clear color to black, fully opaque
						gl.enable(gl.DEPTH_TEST);                               // Enable depth testing
						gl.depthFunc(gl.LEQUAL);                                // Near things obscure far things
						gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);      // Clear the color as well as the depth buffer.
					}
				}
			
				function initShaders() {
					var fragmentShader = getShader(gl, "shader-fs");
					var vertexShader = getShader(gl, "shader-vs");
					  
					// Create the shader program
					  
					shaderProgram = gl.createProgram();
					gl.attachShader(shaderProgram, vertexShader);
					gl.attachShader(shaderProgram, fragmentShader);
					gl.linkProgram(shaderProgram);
					  
					// If creating the shader program failed, alert
					  
					if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
						alert("Unable to initialize the shader program.");
					}
					  
					gl.useProgram(shaderProgram);
					  
					vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
					gl.enableVertexAttribArray(vertexPositionAttribute);
				}
				
				function getShader(gl, id) {
					var shaderScript, theSource, currentChild, shader;
					  
					shaderScript = document.getElementById(id);
					  
					if (!shaderScript) {
						return null;
					}
					  
					theSource = "";
					currentChild = shaderScript.firstChild;
					  
					while(currentChild) {
						if (currentChild.nodeType == currentChild.TEXT_NODE) {
							theSource += currentChild.textContent;
						}
					    
						currentChild = currentChild.nextSibling;
					}
				
					if (shaderScript.type == "x-shader/x-fragment") {
						shader = gl.createShader(gl.FRAGMENT_SHADER);
					} 
					else if (shaderScript.type == "x-shader/x-vertex") {
						shader = gl.createShader(gl.VERTEX_SHADER);
					} 
					else {
						// Unknown shader type
						return null;
					}
				
					gl.shaderSource(shader, theSource);
					    
					// Compile the shader program
					gl.compileShader(shader);  
					    
					// See if it compiled successfully
					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
						alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));  
						return null;  
					}
				    
					return shader;
				}
				
				/* modify rendered resolution of WebGL context:
					gl.viewport(0, 0, canvas.width, canvas.height);
				*/
			</script>
	</body>
</html>
